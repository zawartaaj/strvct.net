
var Stream = window.stream;

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./entry.js":
/*!******************!*\
  !*** ./entry.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var clarinet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clarinet */ \"../../node_modules/clarinet/clarinet.js\");\n/* harmony import */ var clarinet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(clarinet__WEBPACK_IMPORTED_MODULE_0__);\n \nwindow.clarinet = clarinet__WEBPACK_IMPORTED_MODULE_0__;\n\n\n//# sourceURL=webpack:///./entry.js?");

/***/ }),

/***/ "../../node_modules/clarinet/clarinet.js":
/*!***********************************************!*\
  !*** ../../node_modules/clarinet/clarinet.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval(";(function (clarinet) {\n  \"use strict\";\n\n  // non node-js needs to set clarinet debug on root\n  var env =(typeof process === 'object' && process.env)\n    ? process.env\n    : self;\n\n  clarinet.parser            = function (opt) { return new CParser(opt);};\n  clarinet.CParser           = CParser;\n  clarinet.CStream           = CStream;\n  clarinet.createStream      = createStream;\n  clarinet.MAX_BUFFER_LENGTH = 64 * 1024;\n  clarinet.DEBUG             = (env.CDEBUG==='debug');\n  clarinet.INFO              = (env.CDEBUG==='debug' || env.CDEBUG==='info');\n  clarinet.EVENTS            =\n    [ \"value\"\n    , \"string\"\n    , \"key\"\n    , \"openobject\"\n    , \"closeobject\"\n    , \"openarray\"\n    , \"closearray\"\n    , \"error\"\n    , \"end\"\n    , \"ready\"\n    ];\n\n  var buffers     = {\n        textNode: undefined,\n        numberNode: \"\"\n    }\n    , streamWraps = clarinet.EVENTS.filter(function (ev) {\n          return ev !== \"error\" && ev !== \"end\";\n        })\n    , S           = 0\n    , Stream\n    ;\n\n  clarinet.STATE =\n    { BEGIN                             : S++\n    , VALUE                             : S++ // general stuff\n    , OPEN_OBJECT                       : S++ // {\n    , CLOSE_OBJECT                      : S++ // }\n    , OPEN_ARRAY                        : S++ // [\n    , CLOSE_ARRAY                       : S++ // ]\n    , TEXT_ESCAPE                       : S++ // \\ stuff\n    , STRING                            : S++ // \"\"\n    , BACKSLASH                         : S++\n    , END                               : S++ // No more stack\n    , OPEN_KEY                          : S++ // , \"a\"\n    , CLOSE_KEY                         : S++ // :\n    , TRUE                              : S++ // r\n    , TRUE2                             : S++ // u\n    , TRUE3                             : S++ // e\n    , FALSE                             : S++ // a\n    , FALSE2                            : S++ // l\n    , FALSE3                            : S++ // s\n    , FALSE4                            : S++ // e\n    , NULL                              : S++ // u\n    , NULL2                             : S++ // l\n    , NULL3                             : S++ // l\n    , NUMBER_DECIMAL_POINT              : S++ // .\n    , NUMBER_DIGIT                      : S++ // [0-9]\n    };\n\n  for (var s_ in clarinet.STATE) clarinet.STATE[clarinet.STATE[s_]] = s_;\n\n  // switcharoo\n  S = clarinet.STATE;\n\n  const Char = {\n    tab                 : 0x09,     // \\t\n    lineFeed            : 0x0A,     // \\n\n    carriageReturn      : 0x0D,     // \\r\n    space               : 0x20,     // \" \"\n\n    doubleQuote         : 0x22,     // \"\n    plus                : 0x2B,     // +\n    comma               : 0x2C,     // ,\n    minus               : 0x2D,     // -\n    period              : 0x2E,     // .\n\n    _0                  : 0x30,     // 0\n    _9                  : 0x39,     // 9\n\n    colon               : 0x3A,     // :\n\n    E                   : 0x45,     // E\n\n    openBracket         : 0x5B,     // [\n    backslash           : 0x5C,     // \\\n    closeBracket        : 0x5D,     // ]\n\n    a                   : 0x61,     // a\n    b                   : 0x62,     // b\n    e                   : 0x65,     // e \n    f                   : 0x66,     // f\n    l                   : 0x6C,     // l\n    n                   : 0x6E,     // n\n    r                   : 0x72,     // r\n    s                   : 0x73,     // s\n    t                   : 0x74,     // t\n    u                   : 0x75,     // u\n\n    openBrace           : 0x7B,     // {\n    closeBrace          : 0x7D,     // }\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function f () { this[\"__proto__\"] = o; }\n      f.prototype = o;\n      return new f;\n    };\n  }\n\n  if (!Object.getPrototypeOf) {\n    Object.getPrototypeOf = function (o) {\n      return o[\"__proto__\"];\n    };\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = [];\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n      return a;\n    };\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(clarinet.MAX_BUFFER_LENGTH, 10)\n      , maxActual = 0\n      ;\n    for (var buffer in buffers) {\n      var len = parser[buffer] === undefined ? 0 : parser[buffer].length;\n      if (len > maxAllowed) {\n        switch (buffer) {\n          case \"text\":\n            closeText(parser);\n          break;\n\n          default:\n            error(parser, \"Max buffer length exceeded: \"+ buffer);\n        }\n      }\n      maxActual = Math.max(maxActual, len);\n    }\n    parser.bufferCheckPosition = (clarinet.MAX_BUFFER_LENGTH - maxActual)\n                               + parser.position;\n  }\n\n  function clearBuffers (parser) {\n    for (var buffer in buffers) {\n      parser[buffer] = buffers[buffer];\n    }\n  }\n\n  var stringTokenPattern = /[\\\\\"\\n]/g;\n\n  function CParser (opt) {\n    if (!(this instanceof CParser)) return new CParser (opt);\n\n    var parser = this;\n    clearBuffers(parser);\n    parser.bufferCheckPosition = clarinet.MAX_BUFFER_LENGTH;\n    parser.q        = parser.c = parser.p = \"\";\n    parser.opt      = opt || {};\n    parser.closed   = parser.closedRoot = parser.sawRoot = false;\n    parser.tag      = parser.error = null;\n    parser.state    = S.BEGIN;\n    parser.stack    = new Array();\n    // mostly just for error reporting\n    parser.position = parser.column = 0;\n    parser.line     = 1;\n    parser.slashed  = false;\n    parser.unicodeI = 0;\n    parser.unicodeS = null;\n    parser.depth    = 0;\n    emit(parser, \"onready\");\n  }\n\n  CParser.prototype =\n    { end    : function () { end(this); }\n    , write  : write\n    , resume : function () { this.error = null; return this; }\n    , close  : function () { return this.write(null); }\n    };\n\n  try        { Stream = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()); }\n  catch (ex) { Stream = function () {}; }\n\n  function createStream (opt) { return new CStream(opt); }\n\n  function CStream (opt) {\n    if (!(this instanceof CStream)) return new CStream(opt);\n\n    this._parser = new CParser(opt);\n    this.writable = true;\n    this.readable = true;\n\n    //var Buffer = this.Buffer || function Buffer () {}; // if we don't have Buffers, fake it so we can do `var instanceof Buffer` and not throw an error\n    this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n    this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n    this.temp_buffs = { \"2\": new Buffer(2), \"3\": new Buffer(3), \"4\": new Buffer(4) }; // for rebuilding chars split before boundary is reached\n    this.string = '';\n\n    var me = this;\n    Stream.apply(me);\n\n    this._parser.onend = function () { me.emit(\"end\"); };\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er);\n      me._parser.error = null;\n    };\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev,\n        { get          : function () { return me._parser[\"on\" + ev]; }\n        , set          : function (h) {\n            if (!h) {\n              me.removeAllListeners(ev);\n              me._parser[\"on\"+ev] = h;\n              return h;\n            }\n            me.on(ev, h);\n          }\n        , enumerable   : true\n        , configurable : false\n        });\n    });\n  }\n\n  CStream.prototype = Object.create(Stream.prototype,\n    { constructor: { value: CStream } });\n\n  CStream.prototype.write = function (data) {\n    data = new Buffer(data);\n    for (var i = 0; i < data.length; i++) {\n      var n = data[i];\n\n      // check for carry over of a multi byte char split between data chunks\n      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n      if (this.bytes_remaining > 0) {\n        for (var j = 0; j < this.bytes_remaining; j++) {\n          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = data[j];\n        }\n        this.string = this.temp_buffs[this.bytes_in_sequence].toString();\n        this.bytes_in_sequence = this.bytes_remaining = 0;\n\n        // move iterator forward by number of byte read during sequencing\n        i = i + j - 1;\n\n        // pass data to parser and move forward to parse rest of data\n        this._parser.write(this.string);\n        this.emit(\"data\", this.string);\n        continue;\n      }\n\n      // if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n      if (this.bytes_remaining === 0 && n >= 128) {\n        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;\n        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;\n        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;\n        if ((this.bytes_in_sequence + i) > data.length) { // if bytes needed to complete char fall outside data length, we have a boundary split\n\n          for (var k = 0; k <= (data.length - 1 - i); k++) {\n            this.temp_buffs[this.bytes_in_sequence][k] = data[i + k]; // fill temp data of correct size with bytes available in this chunk\n          }\n          this.bytes_remaining = (i + this.bytes_in_sequence) - data.length;\n\n          // immediately return as we need another chunk to sequence the character\n          return true;\n        } else {\n          this.string = data.slice(i, (i + this.bytes_in_sequence)).toString();\n          i = i + this.bytes_in_sequence - 1;\n\n          this._parser.write(this.string);\n          this.emit(\"data\", this.string);\n          continue;\n        }\n      }\n\n      // is there a range of characters that are immediately parsable?\n      for (var p = i; p < data.length; p++) {\n        if (data[p] >= 128) break;\n      }\n      this.string = data.slice(i, p).toString();\n      this._parser.write(this.string);\n      this.emit(\"data\", this.string);\n      i = p - 1;\n\n      // handle any remaining characters using multibyte logic\n      continue;\n    }\n  };\n\n  CStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) this._parser.write(chunk.toString());\n    this._parser.end();\n    return true;\n  };\n\n  CStream.prototype.on = function (ev, handler) {\n    var me = this;\n    if (!me._parser[\"on\"+ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\"+ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]]\n                 : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n    return Stream.prototype.on.call(me, ev, handler);\n  };\n\n  CStream.prototype.destroy = function () {\n    clearBuffers(this._parser);\n    this.emit(\"close\");\n  };\n\n  function emit(parser, event, data) {\n    if(clarinet.INFO) console.log('-- emit', event, data);\n    if (parser[event]) parser[event](data);\n  }\n\n  function emitNode(parser, event, data) {\n    closeValue(parser);\n    emit(parser, event, data);\n  }\n\n  function closeValue(parser, event) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode !== undefined) {\n      emit(parser, (event ? event : \"onvalue\"), parser.textNode);\n    }\n    parser.textNode = undefined;\n  }\n\n  function closeNumber(parser) {\n    if (parser.numberNode)\n      emit(parser, \"onvalue\", parseFloat(parser.numberNode));\n    parser.numberNode = \"\";\n  }\n\n  function textopts (opt, text) {\n    if (text === undefined) {\n      return text;\n    }\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n\n  function error (parser, er) {\n    closeValue(parser);\n    er += \"\\nLine: \"+parser.line+\n          \"\\nColumn: \"+parser.column+\n          \"\\nChar: \"+parser.c;\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n\n  function end(parser) {\n    if (parser.state !== S.VALUE || parser.depth !== 0)\n      error(parser, \"Unexpected end\");\n\n    closeValue(parser);\n    parser.c      = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    CParser.call(parser, parser.opt);\n    return parser;\n  }\n\n  function isWhitespace(c) {\n    return c === Char.carriageReturn || c === Char.lineFeed || c === Char.space || c === Char.tab;\n  }\n\n  function write (chunk) {\n    var parser = this;\n    if (this.error) throw this.error;\n    if (parser.closed) return error(parser,\n      \"Cannot write after close. Assign an onready handler.\");\n    if (chunk === null) return end(parser);\n    var i = 0, c = chunk.charCodeAt(0), p = parser.p;\n    var lockIncrements = false;\n    if (clarinet.DEBUG) console.log('write -> [' + chunk + ']');\n    while (c) {\n      p = c;\n      parser.c = c = chunk.charCodeAt(i++);\n      // if chunk doesnt have next, like streaming char by char\n      // this way we need to check if previous is really previous\n      // if not we need to reset to what the parser says is the previous\n      // from buffer\n      if(p !== c ) parser.p = p;\n      else p = parser.p;\n\n      if(!c) break;\n\n      if (clarinet.DEBUG) console.log(i,c,clarinet.STATE[parser.state]);\n      if (!lockIncrements) {\n        parser.position ++;\n        if (c === Char.lineFeed) {\n          parser.line ++;\n          parser.column = 0;\n        } else parser.column ++;\n      } else {\n        lockIncrements = false;\n      }\n      switch (parser.state) {\n\n        case S.BEGIN:\n          if (c === Char.openBrace) parser.state = S.OPEN_OBJECT;\n          else if (c === Char.openBracket) parser.state = S.OPEN_ARRAY;\n          else if (!isWhitespace(c))\n            error(parser, \"Non-whitespace before {[.\");\n        continue;\n\n        case S.OPEN_KEY:\n        case S.OPEN_OBJECT:\n          if (isWhitespace(c)) continue;\n          if(parser.state === S.OPEN_KEY) parser.stack.push(S.CLOSE_KEY);\n          else {\n            if(c === Char.closeBrace) {\n              emit(parser, 'onopenobject');\n              this.depth++;\n              emit(parser, 'oncloseobject');\n              this.depth--;\n              parser.state = parser.stack.pop() || S.VALUE;\n              continue;\n            } else  parser.stack.push(S.CLOSE_OBJECT);\n          }\n          if(c === Char.doubleQuote) parser.state = S.STRING;\n          else error(parser, \"Malformed object key should start with \\\"\");\n        continue;\n\n        case S.CLOSE_KEY:\n        case S.CLOSE_OBJECT:\n          if (isWhitespace(c)) continue;\n          var event = (parser.state === S.CLOSE_KEY) ? 'key' : 'object';\n          if(c === Char.colon) {\n            if(parser.state === S.CLOSE_OBJECT) {\n              parser.stack.push(S.CLOSE_OBJECT);\n              closeValue(parser, 'onopenobject');\n               this.depth++;\n            } else closeValue(parser, 'onkey');\n            parser.state  = S.VALUE;\n          } else if (c === Char.closeBrace) {\n            emitNode(parser, 'oncloseobject');\n            this.depth--;\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else if(c === Char.comma) {\n            if(parser.state === S.CLOSE_OBJECT)\n              parser.stack.push(S.CLOSE_OBJECT);\n            closeValue(parser);\n            parser.state  = S.OPEN_KEY;\n          } else error(parser, 'Bad object');\n        continue;\n\n        case S.OPEN_ARRAY: // after an array there always a value\n        case S.VALUE:\n          if (isWhitespace(c)) continue;\n          if(parser.state===S.OPEN_ARRAY) {\n            emit(parser, 'onopenarray');\n            this.depth++;\n            parser.state = S.VALUE;\n            if(c === Char.closeBracket) {\n              emit(parser, 'onclosearray');\n              this.depth--;\n              parser.state = parser.stack.pop() || S.VALUE;\n              continue;\n            } else {\n              parser.stack.push(S.CLOSE_ARRAY);\n            }\n          }\n               if(c === Char.doubleQuote) parser.state = S.STRING;\n          else if(c === Char.openBrace) parser.state = S.OPEN_OBJECT;\n          else if(c === Char.openBracket) parser.state = S.OPEN_ARRAY;\n          else if(c === Char.t) parser.state = S.TRUE;\n          else if(c === Char.f) parser.state = S.FALSE;\n          else if(c === Char.n) parser.state = S.NULL;\n          else if(c === Char.minus) { // keep and continue\n            parser.numberNode += \"-\";\n          } else if(Char._0 <= c && c <= Char._9) {\n            parser.numberNode += String.fromCharCode(c);\n            parser.state = S.NUMBER_DIGIT;\n          } else               error(parser, \"Bad value\");\n        continue;\n\n        case S.CLOSE_ARRAY:\n          if(c === Char.comma) {\n            parser.stack.push(S.CLOSE_ARRAY);\n            closeValue(parser, 'onvalue');\n            parser.state  = S.VALUE;\n          } else if (c === Char.closeBracket) {\n            emitNode(parser, 'onclosearray');\n            this.depth--;\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else if (isWhitespace(c))\n              continue;\n          else error(parser, 'Bad array');\n        continue;\n\n        case S.STRING:\n          if (parser.textNode === undefined) {\n            parser.textNode = \"\";\n          }\n\n          // thanks thejh, this is an about 50% performance improvement.\n          var starti              = i-1\n            , slashed = parser.slashed\n            , unicodeI = parser.unicodeI\n            ;\n          STRING_BIGLOOP: while (true) {\n            if (clarinet.DEBUG)\n              console.log(i,c,clarinet.STATE[parser.state]\n                         ,slashed);\n            // zero means \"no unicode active\". 1-4 mean \"parse some more\". end after 4.\n            while (unicodeI > 0) {\n              parser.unicodeS += String.fromCharCode(c);\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              if (unicodeI === 4) {\n                // TODO this might be slow? well, probably not used too often anyway\n                parser.textNode += String.fromCharCode(parseInt(parser.unicodeS, 16));\n                unicodeI = 0;\n                starti = i-1;\n              } else {\n                unicodeI++;\n              }\n              // we can just break here: no stuff we skipped that still has to be sliced out or so\n              if (!c) break STRING_BIGLOOP;\n            }\n            if (c === Char.doubleQuote && !slashed) {\n              parser.state = parser.stack.pop() || S.VALUE;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n            if (c === Char.backslash && !slashed) {\n              slashed = true;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              if (!c) break;\n            }\n            if (slashed) {\n              slashed = false;\n                   if (c === Char.n) { parser.textNode += '\\n'; }\n              else if (c === Char.r) { parser.textNode += '\\r'; }\n              else if (c === Char.t) { parser.textNode += '\\t'; }\n              else if (c === Char.f) { parser.textNode += '\\f'; }\n              else if (c === Char.b) { parser.textNode += '\\b'; }\n              else if (c === Char.u) {\n                // \\uxxxx. meh!\n                unicodeI = 1;\n                parser.unicodeS = '';\n              } else {\n                parser.textNode += String.fromCharCode(c);\n              }\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              starti = i-1;\n              if (!c) break;\n              else continue;\n            }\n\n            stringTokenPattern.lastIndex = i;\n            var reResult = stringTokenPattern.exec(chunk);\n            if (reResult === null) {\n              i = chunk.length+1;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n            i = reResult.index+1;\n            c = chunk.charCodeAt(reResult.index);\n            if (!c) {\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n          }\n          parser.slashed = slashed;\n          parser.unicodeI = unicodeI;\n        continue;\n\n        case S.TRUE:\n          if (c === Char.r) parser.state = S.TRUE2;\n          else error(parser, 'Invalid true started with t'+ c);\n        continue;\n\n        case S.TRUE2:\n          if (c === Char.u) parser.state = S.TRUE3;\n          else error(parser, 'Invalid true started with tr'+ c);\n        continue;\n\n        case S.TRUE3:\n          if(c === Char.e) {\n            emit(parser, \"onvalue\", true);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid true started with tru'+ c);\n        continue;\n\n        case S.FALSE:\n          if (c === Char.a) parser.state = S.FALSE2;\n          else error(parser, 'Invalid false started with f'+ c);\n        continue;\n\n        case S.FALSE2:\n          if (c === Char.l) parser.state = S.FALSE3;\n          else error(parser, 'Invalid false started with fa'+ c);\n        continue;\n\n        case S.FALSE3:\n          if (c === Char.s) parser.state = S.FALSE4;\n          else error(parser, 'Invalid false started with fal'+ c);\n        continue;\n\n        case S.FALSE4:\n          if (c === Char.e) {\n            emit(parser, \"onvalue\", false);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid false started with fals'+ c);\n        continue;\n\n        case S.NULL:\n          if (c === Char.u) parser.state = S.NULL2;\n          else error(parser, 'Invalid null started with n'+ c);\n        continue;\n\n        case S.NULL2:\n          if (c === Char.l) parser.state = S.NULL3;\n          else error(parser, 'Invalid null started with nu'+ c);\n        continue;\n\n        case S.NULL3:\n          if(c === Char.l) {\n            emit(parser, \"onvalue\", null);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid null started with nul'+ c);\n        continue;\n\n        case S.NUMBER_DECIMAL_POINT:\n          if(c === Char.period) {\n            parser.numberNode += \".\";\n            parser.state       = S.NUMBER_DIGIT;\n          } else error(parser, 'Leading zero not followed by .');\n        continue;\n\n        case S.NUMBER_DIGIT:\n          if(Char._0 <= c && c <= Char._9) parser.numberNode += String.fromCharCode(c);\n          else if (c === Char.period) {\n            if(parser.numberNode.indexOf('.')!==-1)\n              error(parser, 'Invalid number has two dots');\n            parser.numberNode += \".\";\n          } else if (c === Char.e || c === Char.E) {\n            if(parser.numberNode.indexOf('e')!==-1 ||\n               parser.numberNode.indexOf('E')!==-1 )\n               error(parser, 'Invalid number has two exponential');\n            parser.numberNode += \"e\";\n          } else if (c === Char.plus || c === Char.minus) {\n            if(!(p === Char.e || p === Char.E))\n              error(parser, 'Invalid symbol in number');\n            parser.numberNode += String.fromCharCode(c);\n          } else {\n            closeNumber(parser);\n            i--; // go back one\n            lockIncrements = true; // do not apply increments for a single cycle\n            parser.state = parser.stack.pop() || S.VALUE;\n          }\n        continue;\n\n        default:\n          error(parser, \"Unknown state: \" + parser.state);\n      }\n    }\n    if (parser.position >= parser.bufferCheckPosition)\n      checkBufferLength(parser);\n    return parser;\n  }\n\n})( false ? 0 : exports);\n\n\n//# sourceURL=webpack:///../../node_modules/clarinet/clarinet.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./entry.js");
/******/ 	
/******/ })()
;